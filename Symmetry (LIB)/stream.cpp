/**                  ====================                      *
  *      _____                                __               *
  *     / ___/__  ______ ___  ____ ___  ___  / /________  __   *
  *     \__ \/ / / / __ `__ \/ __ `__ \/ _ \/ __/ ___/ / / /   *
  *    ___/ / /_/ / / / / / / / / / / /  __/ /_/ /  / /_/ /    *
  *   /____/\__, /_/ /_/ /_/_/ /_/ /_/\___/\__/_/   \__, /     * 
  *        /____/                                  /____/      *
  *   - by Defc0n                                              *
  *                  ====================                      **/

#include "stream.h"

NAMESPACE_LIB(IO)

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn Stream::Stream()
///
/// \brief Constructor.
////////////////////////////////////////////////////////////////////////////////////////////////////

Stream::Stream()
{
	this->m_bAutoFlush	= false;
	this->m_ssStream	= stringstream();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn Stream::Stream()
///
/// \brief Constructor.
////////////////////////////////////////////////////////////////////////////////////////////////////

Stream::Stream(string sData)
{
	this->m_bAutoFlush	= false;
	this->m_ssStream	= stringstream(sData);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn Stream::~Stream()
///
/// \brief Destructor.
////////////////////////////////////////////////////////////////////////////////////////////////////

Stream::~Stream()
{
	// ball on shams
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::OnBytesIn(uchar* cData, uint64 iSize)
///
/// \brief Called when bytes are read.  this function should set cData's value 
/// 	   to whatever's meant to be read from wherever.  Default behaviour is
/// 	   read iSize bytes into cData from the underlying stringstream object. 
///
/// \param [in,out] cData Pointer to a location in memory, iSize bytes will be written
/// 				into this memory address.
/// \param iSize		  The amount of bytes to read.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::OnBytesIn(uchar* cData, uint64 iSize)
{
	this->m_ssStream.read((char*)cData, iSize);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::OnBytesOut(uchar* cData, uint64 iSize)
///
/// \brief Writes iSize bytes from cData into something.  Default behaviour writes
/// 	   the data into the underlying stringstream object.
///
/// \param [in,out] cData Data to write.
/// \param iSize		  Size of the data to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::OnBytesOut(uchar* cData, uint64 iSize)
{
	this->m_ssStream.write((char*)cData, iSize);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	void Stream::Write7BitEncodedInt(int iValue)
///
/// \brief	Encodes an integer as a 7bit integer and writes.  The source of this function
/// 		was taken from .NET using a .NET decompiler.  This code is not mine.
///
/// \param	iValue	Integer to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write7BitEncodedInt(int iValue)
{
	uint32 num = (uint32)iValue;

	while (num >= 128U)
	{
		this->Write((uchar)(num | 128U));
		num >>= 7;
	}

	this->Write((uchar)num);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	int Stream::Read7BitEncodedInt()
///
/// \brief	Reads 7 bit encoded integer, like that sent from the function above. The source of this
/// 		function was taken from .NET using a .NET decompiler.  This code is not mine.
///
/// \return	The 7 bit encoded integer.
////////////////////////////////////////////////////////////////////////////////////////////////////

int Stream::Read7BitEncodedInt()
{
	int ret = 0;
	for (char i = 0;;i++)
	{
		uchar b = this->ReadByte();
		ret |= (b & 127) << (i * 7);

		if (!(b & 128))
			break;
	}

	return ret;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Flush()
///
/// \brief Flushes the buffer, designed to be overloaded.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Flush()
{
	// This is how you clear stringstreams apparently
	this->m_ssStream.str(string());
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::SetAutoFlush(bool b)
///
/// \brief Enables/disables automatic flushing.  When enabled each write call will call Stream::Flush
/// 	   afterwards.
///
/// \param b
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::SetAutoFlush(bool b)
{
	this->m_bAutoFlush = b;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Seek(size_t sPos)
///
/// \brief Attempts to set the read/write position in the stream
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Seek(streamoff sPos)
{
	this->m_ssStream.seekg(sPos);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn size_t Stream::Tell()
///
/// \brief Returns the current read/write position of the stream
///
/// \return .
////////////////////////////////////////////////////////////////////////////////////////////////////

streamoff Stream::Tell()
{
	return this->m_ssStream.tellg();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn size_t Stream::GetSize()
///
/// \brief Returns the amount of bytes contained in the stream
/// 	   
/// \return .
////////////////////////////////////////////////////////////////////////////////////////////////////

streamoff Stream::GetStreamSize()
{
	streamoff sPos = this->Tell(), sSize = 0; 

	this->m_ssStream.seekp(0, ios::end);
	sSize = this->m_ssStream.tellp();
	this->m_ssStream.seekp(sPos);

	return sSize;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn stringstream Stream::GetSStream()
///
/// \brief Gets the underlying string stream.
///
/// \return .
////////////////////////////////////////////////////////////////////////////////////////////////////

stringstream Stream::GetSStream()
{
	return stringstream();
}

#pragma region Write functions
////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn } void Stream::Write(short sVal)
///
/// \brief Writes a 16bit integer.
///
/// \param sVal The value to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(int16 iVal)
{
	this->Write<int16>(iVal);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Write(int iVal)
///
/// \brief Writes a 32bit integer.
///
/// \param iVal The value to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(int32 iVal)
{
	this->Write<int32>(iVal);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Write(long long llVal)
///
/// \brief Writes a 64bit integer. 
///
/// \param llVal The value to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(int64 iVal)
{
	this->Write<int64>(iVal);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Write(unsigned short usVal)
///
/// \brief Writes an unsigned 16bit integer.
///
/// \param usVal The value to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(uint16 iVal)
{
	this->Write<uint16>(iVal);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Write(unsigned int uiVal)
///
/// \brief Writes an unsigned 32bit integer.
///
/// \param uiVal The value to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(uint32 iVal)
{
	this->Write<uint32>(iVal);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Write(unsigned long long ullVal)
///
/// \brief Writes an unsigned 64bit integer.
///
/// \param ullVal The value to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(uint64 iVal)
{
	this->Write<uint64>(iVal);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Write(float fVal)
///
/// \brief Writes a 4byte floating-point integer.
///
/// \param fVal The value to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(float fVal)
{
	this->Write<float>(fVal);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Write(double dVal)
///
/// \brief Writes a 8byte floating-point integer.
///
/// \param dVal The value to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(double dVal)
{
	this->Write<double>(dVal);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	void Stream::Write(string sVal, bool bSendLength)
///
/// \brief	Writes a C++ string, uses .length.
///
/// \param	sVal	   	The string to write.
/// \param	bSendLength	If this is true the length of the string is written as 7bit encoded 
/// 					integer.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(string sVal, bool bSendLength)
{
	if (bSendLength)
		this->Write7BitEncodedInt(sVal.length());

	this->OnBytesOut( (uchar*)sVal.c_str(), sVal.length() );
	if (this->m_bAutoFlush) this->Flush();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Write(const char* ccVal)
///
/// \brief Writes a const char* (string ptr), must be null-terminated
///
/// \param ccVal The string to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(char_c* ccVal)
{
	this->OnBytesOut( (uchar*)ccVal, strlen( ccVal ) );
	if (this->m_bAutoFlush) this->Flush();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	void Stream::Write(uchar* ucVal, uint32 iLength)
///
/// \brief	Writes an unsigned const char*, writing is done the same way as above except 
/// 		with an option iLength argument for strings that contain null terminators.
///
/// \param [in,out]	ucVal	The string to wrie.
/// \param	iLength		 	Zero-based index of the length.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(uchar* ucVal, uint32 iLength)
{
	this->OnBytesOut(ucVal, iLength == 0 ? strlen(reinterpret_cast<char*>(ucVal)) : iLength);
	if (this->m_bAutoFlush) this->Flush();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Write(char cVal)
///
/// \brief Writes a single character.
///
/// \param cVal The character to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(char cVal)
{
	this->Write<char>(cVal);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn void Stream::Write(unsigned char ucVal)
///
/// \brief Writes a single unsigned character.
///
/// \param ucVal The value to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(uchar ucVal)
{
	this->Write<uchar>(ucVal);
}  

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	void Stream::Write(bool bVal)
///
/// \brief	Writes a single boolean, as a byte.  1 = true, 0 = false.
///
/// \param	bVal	The value to write.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::Write(bool bVal)
{
	this->Write<uchar>(bVal ? 1 : 0);
}

#pragma endregion

#pragma region Read functions
////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn short Stream::ReadInt16()
///
/// \brief Reads a 16bit integer.  Advances 2 bytes into the stream.
///
/// \return A 16 bit integer.
////////////////////////////////////////////////////////////////////////////////////////////////////

int16 Stream::ReadInt16()
{
	return this->Read<int16>();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn int Stream::ReadInt32()
///
/// \brief Reads a 32bit integer.  Advances 4 bytes into the stream.
///
/// \return A 32 bit integer.
////////////////////////////////////////////////////////////////////////////////////////////////////

int32 Stream::ReadInt32()
{
	return this->Read<int32>();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn long long Stream::ReadInt64()
///
/// \brief Reads a 64bit integer.  Advances 8 bytes into the stream.
///
/// \return A 64 bit integer.
////////////////////////////////////////////////////////////////////////////////////////////////////

int64 Stream::ReadInt64()
{
	return this->Read<int64>();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn unsigned short Stream::ReadUInt16()
///
/// \brief Reads an unsigned 16bit integer.  Advances 2 bytes into the stream.
///
/// \return An unsigned 16 bit integer.
////////////////////////////////////////////////////////////////////////////////////////////////////

uint16 Stream::ReadUInt16()
{
	return this->Read<uint16>();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn unsigned int Stream::ReadUInt32()
///
/// \brief Reads an unsigned 32bit integer.  Advances 4 bytes into the stream.
///
/// \return An unsigned 32 bit integer.
////////////////////////////////////////////////////////////////////////////////////////////////////

uint32 Stream::ReadUInt32()
{
	return this->Read<uint32>();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn unsigned long long Stream::ReadUInt64()
///
/// \brief Reads unsigned 64 bit integer.  Advances 8 bytes into the stream
///
/// \return An unsigned 64 bit integer.
////////////////////////////////////////////////////////////////////////////////////////////////////

uint64 Stream::ReadUInt64()
{
	return this->Read<uint64>();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn float Stream::ReadFloat()
///
/// \brief Reads a 4byte floating point value.  Advances 4 bytes into the stream.
///
/// \return A 4 byte floating point value.
////////////////////////////////////////////////////////////////////////////////////////////////////

float Stream::ReadFloat()
{
	return this->Read<float>();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn double Stream::ReadDouble()
///
/// \brief Read a 8byte floating point value.  Advances 8 bytes into the stream.
///
/// \return A 8 byte floating point value.
////////////////////////////////////////////////////////////////////////////////////////////////////

double Stream::ReadDouble()
{
	return this->Read<double>();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	char_c* Stream::ReadChars(uint32 iSize)
///
/// \brief	Reads sSize characters from the stream, returned string is null-terminated. Advances
/// 		sSize bytes into the stream.
///
/// \param	iSize	Number of characters to read.
///
/// \return	sSize characters from the stream.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::ReadChars(char* cBuffer, uint32 iSize)
{
	for (uint32 i = 0; i < iSize; i++)
		cBuffer[i] = this->ReadChar();

	cBuffer[iSize] = '\0';
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	string Stream::ReadString(uint32 iSize)
///
/// \brief	Reads a C++ string, same as above but the return type is a C++ string, rather than a
/// 		character string pointer.  Advances sSize bytes into the stream.
///
/// \param	iSize	Number of characters to read.
///
/// \return	The string.
////////////////////////////////////////////////////////////////////////////////////////////////////

string Stream::ReadString(uint32 iSize)
{
	string buf;
	for (uint32 i = 0; i < iSize; i++)
		buf += this->ReadChar();

	return buf;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	string Stream::ReadString()
///
/// \brief	Reads a string, the size of the string is read from the stream.  The size of the
/// 		string should be denoted by a 7 bit encoded integer.
///
/// \return	The string.
////////////////////////////////////////////////////////////////////////////////////////////////////

string Stream::ReadString()
{
	return this->ReadString(this->Read7BitEncodedInt());
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	uchar* Stream::ReadBytes(uint32 iSize)
///
/// \brief	Reads sSize bytes.  Bytes are unsigned characters, often used to store unicode
/// 		strings. Advances sSize bytes into the stream.  Returned "string" is not null
/// 		terminated and supports reading NULL characters.
///
/// \param	iSize	Number of bytes.
///
/// \return	The string of bytes.
////////////////////////////////////////////////////////////////////////////////////////////////////

void Stream::ReadBytes(uchar* cBuffer, uint32 iSize)
{
	for (int64 i = 0; i < iSize; i++)
		cBuffer[i] = this->ReadByte();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn char Stream::ReadChar()
///
/// \brief Reads a single character from the stream.  Advances 1 byte into the stream.
///
/// \return A character.
////////////////////////////////////////////////////////////////////////////////////////////////////

char Stream::ReadChar()
{
	return this->Read<char>();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn unsigned char Stream::ReadByte()
///
/// \brief Reads a single byte from the stream.  Same as reading a character, but skips casting
/// 	   requirements.  Unsigned characters (bytes) could contain unicode characters.
///
/// \return A byte.
////////////////////////////////////////////////////////////////////////////////////////////////////

uchar Stream::ReadByte()
{
	return this->Read<uchar>();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn string Stream::ReadUntil(char cChar, bool bInclude)
///
/// \brief Reads characters until cChar is found.  UNSAFE: MAKE SURE CCHAR ACTUALLY EXISTS.
///
/// \param cChar    The character to read until.
/// \param bInclude True to read the last character in the returned string, false
/// 				if you don't want that character.
///
/// \return .
////////////////////////////////////////////////////////////////////////////////////////////////////

string Stream::ReadUntil(char cChar, bool bInclude)
{
	string sBuffer;

	while (true) 
	{
		char c = this->ReadChar();

		if (c == cChar)
		{
			if (bInclude)
			{
				sBuffer += c;
			}
			break;
		}

		sBuffer += c;
	}
	
	return sBuffer;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn string Stream::ReadLine()
///
/// \brief Reads a line from the stream (calls ReadUntil with a newline character)
///
/// \return A line from the stream.
////////////////////////////////////////////////////////////////////////////////////////////////////

string Stream::ReadLine()
{
	return this->ReadUntil('\n', true);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	bool Stream::ReadBool()
///
/// \brief	Reads a boolean from the stream.
///
/// \return	A boolean
////////////////////////////////////////////////////////////////////////////////////////////////////

bool Stream::ReadBool()
{
	return this->ReadChar() == 1;
}

#pragma endregion

NAMESPACE_END2