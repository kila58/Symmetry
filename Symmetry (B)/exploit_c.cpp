/**                  ====================                      *
  *      _____                                __               *
  *     / ___/__  ______ ___  ____ ___  ___  / /________  __   *
  *     \__ \/ / / / __ `__ \/ __ `__ \/ _ \/ __/ ___/ / / /   *
  *    ___/ / /_/ / / / / / / / / / / /  __/ /_/ /  / /_/ /    *
  *   /____/\__, /_/ /_/ /_/_/ /_/ /_/\___/\__/_/   \__, /     *
  *        /____/                                  /____/      *
  *   - by Defc0n                                              *
  *                  ====================                      **/

#include "command_args.h"
#include "concommand.h"

#include "global.h"

#include "src_lib.h"

#include "cvarutil.h"

using namespace Core;
using namespace Core::Console;

////////////////////////////////////////////////////////////////////////////////////////////////////
///									  == NAME EXPLOITY STUFF ==
////////////////////////////////////////////////////////////////////////////////////////////////////

// Forward delecrations
void real_name_changed(IConVar*, const char*, float);
void fake_name_changed(SymConVarBase*, string, string);

MakeConVar5(string, fake_name, "Used to override steam name.  Set to 'default' to use steam name.", "default", fake_name_changed);

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	void fake_name_changed(SymConVarBase* pConvar, string sOldVal, string sNewVal)
///
/// \brief	Callback for fake_name.  Sets both the value and callback for the source convar 'name'.
/// 		Callback is stored so that it can be returned to it's original state.  The name convar
/// 		is not returned to it's original state.
////////////////////////////////////////////////////////////////////////////////////////////////////

void fake_name_changed(SymConVarBase* pConvar, string sOldVal, string sNewVal)
{
	// Install source cvar callback on "name"
	ConVar* cv = Src::CVar->FindVar("name");

	// Store original callback
	static FnChangeCallback_t oldCallback = cv->m_fnChangeCallback;

	if (pConvar->GetDefaultValueEx() != sNewVal)
	{
		// Change callback to my super secret callback
		cv->m_fnChangeCallback = real_name_changed;

		// Doesn't call callbacks
		CvarUtil::SetCvar(cv, Mem::ParseSpecialChars(fake_name.GetValue()));

		// This updates the name if we're currently connected, somewhat useful
		Src::CVar->CallGlobalChangeCallbacks(cv, "", 0.0f);
	}
	else
	{
		cv->m_fnChangeCallback = oldCallback;
	}
}                                                            

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	void real_name_changed(IConVar* cVar, const char* cStr, float fl)
///
/// \brief	Callback for the real 'name' convar, this is used to override the old callback and
/// 		stop it from overwriting our new fake name.
////////////////////////////////////////////////////////////////////////////////////////////////////

void real_name_changed(IConVar* cVar, const char* cStr, float fl)
{
	ConVar* cv = Src::CVar->FindVar(cVar->GetName());

	if (fake_name.GetValue() != fake_name.GetDefaultValue())
	{
		// Doesn't call callbacks
		CvarUtil::SetCvar(cv, Mem::ParseSpecialChars(fake_name.GetValue()));

		// This updates the name if we're currently connected, somewhat useful
		Src::CVar->CallGlobalChangeCallbacks(cv, "", 0.0f);
	}
}


////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	void d_shutdown(CommandArgs arg)
////////////////////////////////////////////////////////////////////////////////////////////////////

void sym_dl(CommandArgs arg)
{
	string path = Mem::ParseSpecialChars(arg.GetArgAt(0));

	INetChannel* info = (INetChannel*)SrcLib::GetNetChannelInfo();

	if (info)
	{
		PrintLine("response: %d", (int)info->RequestFile(path.c_str()));
	}
	else
	{
		PrintBadL("Couldn't find net channel");
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	void d_shutdown(CommandArgs arg)
////////////////////////////////////////////////////////////////////////////////////////////////////

void sym_ul(CommandArgs arg)
{
	string path = Mem::ParseSpecialChars(arg.GetArgAt(0));
	int id = 0;

	if (arg.GetArgCount() > 1)
	{
		id = atoi(arg.GetArgAt(1).c_str());
	}

	INetChannel* info = (INetChannel*)SrcLib::GetNetChannelInfo();

	if (info)
	{
		PrintLine("response: %d", (int)info->SendFile(path.c_str(), id));
	}
	else
	{
		PrintBadL("Couldn't find net channel");
	}
}

MakeConCommand4(sym_dl, "Download a file from the server", "sym_dl <path>", 1);
MakeConCommand4(sym_ul, "Upload a file to the server", "sym_ul <path> [transfer id]", 1);