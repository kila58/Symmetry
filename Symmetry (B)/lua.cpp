/**                  ====================                      *
  *      _____                                __               *
  *     / ___/__  ______ ___  ____ ___  ___  / /________  __   *
  *     \__ \/ / / / __ `__ \/ __ `__ \/ _ \/ __/ ___/ / / /   *
  *    ___/ / /_/ / / / / / / / / / / /  __/ /_/ /  / /_/ /    *
  *   /____/\__, /_/ /_/ /_/_/ /_/ /_/\___/\__/_/   \__, /     * 
  *        /____/                                  /____/      *
  *   - by Defc0n                                              *
  *                  ====================                      **/

// Basically an easier way of calling functions in patterns.cpp
// Function body headers were taken from lua.h in Lua 5.2

#include "lua_gmod.h"
#include "patterns.h"

#include "iluashared_h.h"

using namespace Core::Patterns;

// Macro for Lua function definitions (header is defined in C, so the functions must be too)
#define L_LIB extern "C"

NAMESPACE_CORE(Lua)

#ifndef BUILDMODE_TEST

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_pushnil(lua_State *L)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_pushnil(lua_State *L)
{
	Patterns::LuaPushNil(L);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_pushnumber(lua_State *L, lua_Number n)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_pushnumber(lua_State *L, lua_Number n)
{
	Patterns::LuaPushNumber(L, n);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_pushinteger(lua_State *L, lua_Integer n);
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_pushinteger(lua_State *L, lua_Integer n)
{
	Patterns::LuaPushInteger(L, n);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB const char* lua_pushstring(lua_State* L, const char* ccString)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB const char *lua_pushstring(lua_State *L, const char *s)
{
	return Patterns::LuaPushString(L, s);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_pushcclosure(lua_State *L, lua_CFunction fn, int n)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_pushcclosure(lua_State *L, lua_CFunction fn, int n)
{
	Patterns::LuaPushClosure(L, fn, n);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_pushboolean(lua_State *L, int b)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_pushboolean(lua_State *L, int b)
{
	Patterns::LuaPushBoolean(L, b);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_pushlightuserdata(lua_State *L, void *p)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_pushlightuserdata(lua_State *L, void *p)
{
	// memory leak?????????
	UserData* data = new UserData;
	data->data = p;
	data->type = LUA_TUSERDATA;

	Patterns::LuaPushUserData(L, data);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_pushvalue(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_pushvalue(lua_State *L, int idx)
{
	Patterns::LuaPushValue(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_createtable(lua_State *L, int narr, int nrec)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_createtable(lua_State *L, int narr, int nrec)
{
	Patterns::LuaCreateTable(L, narr, nrec);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_gettable(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_gettable(lua_State *L, int idx)
{
	Patterns::LuaGetTable(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_settable(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_settable(lua_State *L, int idx)
{
	Patterns::LuaSetTable(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_getfield(lua_State *L, int idx, const char *k)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_getfield(lua_State *L, int idx, const char *k)
{
	Patterns::LuaGetField(L, idx, k);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_setfield(lua_State *L, int idx, const char *k).
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_setfield(lua_State *L, int idx, const char *k)
{
	Patterns::LuaSetField(L, idx, k);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB lua_Number lua_getnumberx(lua_State*, int idx)
///
/// \brief	Lua lua_tonumber is a macro for lua_tonumberx, where the third argument is NULL.
/// 		In Garrysmod lua_tonumberx doesn't exist, only lua_tonumber.  I'm going to presume
/// 		it works like the macro does.  (Maybe an earlier version of Lua worked like this?)
/// 		
/// 		Another hint to odd behaviour is the fact this function is a __stdcall.  Perhaps 
/// 		lua_tonumber was made in source by Garry and since as lua_tonumberx was never used
/// 		it wasn't compiled in with the binaries?  We'll never know.
/// 		
/// 		Note: isnum is included in the argument list so it's compatible with lua.h, however
/// 		the third argument does nothing.
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB lua_Number lua_tonumberx(lua_State* L, int idx, int* isnum)
{
	return Patterns::LuaToNumber(L, idx, isnum);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB lua_Integer lua_tointergerx(lua_State* L, int idx)
///
/// \brief	Exact same case above.  Read above description for more details.
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB lua_Integer lua_tointegerx(lua_State* L, int idx, int* isnum)
{
	return Patterns::LuaToInteger(L, idx, isnum);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB int lua_toboolean(lua_State* L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB int lua_toboolean(lua_State* L, int idx)
{
	return Patterns::LuaToBoolean(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB const char *lua_tolstring(lua_State *L, int idx, size_t *len)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB const char *lua_tolstring(lua_State *L, int idx, size_t *len)
{
	return Patterns::LuaToLString(L, idx, len);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB lua_CFunction lua_tocfunction(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB lua_CFunction lua_tocfunction(lua_State *L, int idx)
{
	return Patterns::LuaToCFunction(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void *lua_touserdata(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void *lua_touserdata(lua_State *L, int idx)
{
	return Patterns::LuaToUserData(L, idx)->data;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB const void *lua_topointer(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB const void *lua_topointer(lua_State *L, int idx)
{
	return Patterns::LuaToPointer(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB int lua_type(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB int lua_type(lua_State *L, int idx)
{
	return Patterns::LuaType(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB const char *lua_typename(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB const char *lua_typename(lua_State *L, int idx)
{
	int type = Lua::lua_type(L, idx);
	return type <= sizeof(Name) ? Name[type] : "bad type";
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_callk(lua_State *L, int nargs, int nresults, int ctx, lua_CFunction k)
///
/// \brief	Another similar case to lua_tointegerx and lua_tonumberx.  In the Lua headers
/// 		lua_call is a macro for lua_callk, where ctx and k are 0.  In Garrysmod
///			lua_callk doesn't exist, only a function that works like the macro in the header 
///			(lua_call).
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB int lua_callk(lua_State *L, int nargs, int nresults, int ctx, lua_CFunction k)
{
	return Patterns::LuaCall(L, nargs, nresults, ctx, k);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB int (lua_State *L, int nargs, int nresults, int errfunc, int ctx, lua_CFunction k)
///
/// \brief	Another function with the macro-like source definitions.  The last two arguments
/// 		here have no effect
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB int lua_pcallk(lua_State *L, int nargs, int nresults, int errfunc, int ctx, lua_CFunction k)
{
	return Patterns::LuaPCall(L, nargs, nresults, errfunc, ctx, k);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB int luaL_loadstring(lua_State *L, const char *s)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB int luaL_loadstring(lua_State *L, const char *s)
{
	return Patterns::LuaLoadString(L, s);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB int luaL_loadbufferx(lua_State *L, const char *buff, size_t sz, const char *name,
/// 	const char *mod)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB int luaL_loadbufferx(lua_State *L, const char *buff, size_t sz, const char *name, const char *mod)
{
	// hooked, call original
	return Hooks::CLS_LoadBufferX(L, buff, sz, name, mod);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB int luaL_ref(lua_State *L, int t)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB int luaL_ref(lua_State *L, const char* s)
{
	return Patterns::LuaRef(L, s);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void luaL_unref(lua_State *L, int t, int ref)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void luaL_unref(lua_State *L, int t, int ref)
{
	Patterns::LuaUnRef(L, t, ref);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_rawget(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_rawget(lua_State *L, int idx)
{
	Patterns::LuaRawGet(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_rawset(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_rawset(lua_State *L, int idx)
{
	Patterns::LuaRawSet(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_rawgeti(lua_State *L, int idx, int n)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_rawgeti(lua_State *L, int idx, int n)
{
	Patterns::LuaRawGetI(L, idx, n);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_rawseti(lua_State *L, int idx, int n)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_rawseti(lua_State *L, int idx, int n)
{
	Patterns::LuaRawSetI(L, idx, n);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_settop(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_settop(lua_State *L, int idx)
{
	Patterns::LuaSetTop(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB int lua_gettop(lua_State *L)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB int lua_gettop(lua_State *L)
{
	return Patterns::LuaGetTop(L);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_settop(lua_State *L, int idx)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void luaL_checktype(lua_State *L, int narg, int t)
{
	Patterns::LuaCheckType(L, narg, t);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_remove(lua_State *L, int narg, int t)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_remove(lua_State *L, int idx)
{
	Patterns::LuaRemove(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB void lua_replace(lua_State *L, int narg, int t)
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB void lua_replace(lua_State *L, int idx)
{
	Patterns::LuaReplace(L, idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	L_LIB const char *(luaL_checklstring)(lua_State *L, int numArg, size_t *l)
///
/// \brief	luaL_checklstring using luaL_checktype and lua_tolstring.
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB const char *(luaL_checklstring)(lua_State *L, int numArg, size_t *l)
{
	Lua::luaL_checktype(L, numArg, LUA_TSTRING);
	return Lua::lua_tolstring(L, numArg, l);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn	LUA_API int (lua_gc)(lua_State *L, int what, int data);
////////////////////////////////////////////////////////////////////////////////////////////////////

L_LIB int lua_gc(lua_State *L, int what, int data)
{
	return Patterns::LuaGC(L, what, data);
}

#endif

NAMESPACE_END2